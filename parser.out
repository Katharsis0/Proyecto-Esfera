Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DIR
    FALSE
    LSB
    RSB
    STRING
    TRUE

Grammar

Rule 0     S' -> sentences
Rule 1     sentences -> sentences sentence
Rule 2     sentences -> sentence
Rule 3     sentence -> def
Rule 4     sentence -> call
Rule 5     sentence -> alter
Rule 6     sentence -> not
Rule 7     sentence -> condFunction
Rule 8     sentence -> PRINT
Rule 9     keyword -> procedure
Rule 10    keyword -> procedure procedure
Rule 11    keyword -> MAIN
Rule 12    body -> iterative
Rule 13    body -> CASE
Rule 14    body -> DEF
Rule 15    body -> MOVER
Rule 16    body -> ALEATORIO
Rule 17    body -> sentence
Rule 18    body -> REPEAT
Rule 19    def -> DEF LP ID COMMA TYPE RP SEMICOLON
Rule 20    def -> DEF LP ID COMMA TYPE COMMA value SEMICOLON
Rule 21    alter -> ALTER LP ID COMMA value RP SEMICOLON
Rule 22    not -> NOT LP ID RP SEMICOLON
Rule 23    istrue -> ISTRUE LP ID RP SEMICOLON
Rule 24    iterative -> WHILE condition LP instructions RP SEMICOLON
Rule 25    iterative -> UNTIL LP instructions RP condition SEMICOLON
Rule 26    case -> CASE functions SEMICOLON
Rule 27    case -> CASE ID functions SEMICOLON
Rule 28    call -> CALL LP ID RP SEMICOLON
Rule 29    functions -> function
Rule 30    functions -> functions function
Rule 31    function -> when then
Rule 32    function -> when then else
Rule 33    when -> WHEN LP condition RP
Rule 34    when -> WHEN value
Rule 35    then -> THEN instructions
Rule 36    else -> ELSE instructions
Rule 37    instructions -> instruction
Rule 38    instructions -> instructions instruction
Rule 39    instruction -> sentences
Rule 40    instruction -> body
Rule 41    instruction -> expression
Rule 42    expression -> expression PLUS term
Rule 43    expression -> expression MINUS term
Rule 44    expression -> term
Rule 45    term -> term STAR factor
Rule 46    term -> term SLASH factor
Rule 47    term -> factor
Rule 48    factor -> LP expression RP
Rule 49    factor -> UMINUS factor
Rule 50    factor -> INT
Rule 51    condFunction -> istrue
Rule 52    condition -> oper GT oper
Rule 53    condition -> oper LT oper
Rule 54    condition -> oper EQUAL oper
Rule 55    condition -> oper DIF oper
Rule 56    condition -> oper GTE oper
Rule 57    condition -> oper LTE oper
Rule 58    condition -> condFunction
Rule 59    oper -> value
Rule 60    oper -> expression
Rule 61    value -> ID
Rule 62    value -> INT
Rule 63    value -> BOOL
Rule 64    procedure -> PROC ID LP instructions RP SEMICOLON
Rule 65    comments -> COMMENT

Terminals, with rules where they appear

ALEATORIO            : 16
ALTER                : 21
BOOL                 : 63
CALL                 : 28
CASE                 : 13 26 27
COMMA                : 19 20 20 21
COMMENT              : 65
DEF                  : 14 19 20
DIF                  : 55
DIR                  : 
ELSE                 : 36
EQUAL                : 54
FALSE                : 
GT                   : 52
GTE                  : 56
ID                   : 19 20 21 22 23 27 28 61 64
INT                  : 50 62
ISTRUE               : 23
LP                   : 19 20 21 22 23 24 25 28 33 48 64
LSB                  : 
LT                   : 53
LTE                  : 57
MAIN                 : 11
MINUS                : 43
MOVER                : 15
NOT                  : 22
PLUS                 : 42
PRINT                : 8
PROC                 : 64
REPEAT               : 18
RP                   : 19 21 22 23 24 25 28 33 48 64
RSB                  : 
SEMICOLON            : 19 20 21 22 23 24 25 26 27 28 64
SLASH                : 46
STAR                 : 45
STRING               : 
THEN                 : 35
TRUE                 : 
TYPE                 : 19 20
UMINUS               : 49
UNTIL                : 25
WHEN                 : 33 34
WHILE                : 24
error                : 

Nonterminals, with rules where they appear

alter                : 5
body                 : 40
call                 : 4
case                 : 
comments             : 
condFunction         : 7 58
condition            : 24 25 33
def                  : 3
else                 : 32
expression           : 41 42 43 48 60
factor               : 45 46 47 49
function             : 29 30
functions            : 26 27 30
instruction          : 37 38
instructions         : 24 25 35 36 38 64
istrue               : 51
iterative            : 12
keyword              : 
not                  : 6
oper                 : 52 52 53 53 54 54 55 55 56 56 57 57
procedure            : 9 10 10
sentence             : 1 2 17
sentences            : 1 39 0
term                 : 42 43 44 45 46
then                 : 31 32
value                : 20 21 34 59
when                 : 31 32

Parsing method: LALR

state 0

    (0) S' -> . sentences
    (1) sentences -> . sentences sentence
    (2) sentences -> . sentence
    (3) sentence -> . def
    (4) sentence -> . call
    (5) sentence -> . alter
    (6) sentence -> . not
    (7) sentence -> . condFunction
    (8) sentence -> . PRINT
    (19) def -> . DEF LP ID COMMA TYPE RP SEMICOLON
    (20) def -> . DEF LP ID COMMA TYPE COMMA value SEMICOLON
    (28) call -> . CALL LP ID RP SEMICOLON
    (21) alter -> . ALTER LP ID COMMA value RP SEMICOLON
    (22) not -> . NOT LP ID RP SEMICOLON
    (51) condFunction -> . istrue
    (23) istrue -> . ISTRUE LP ID RP SEMICOLON

    PRINT           shift and go to state 8
    DEF             shift and go to state 9
    CALL            shift and go to state 10
    ALTER           shift and go to state 11
    NOT             shift and go to state 12
    ISTRUE          shift and go to state 14

    sentences                      shift and go to state 1
    sentence                       shift and go to state 2
    def                            shift and go to state 3
    call                           shift and go to state 4
    alter                          shift and go to state 5
    not                            shift and go to state 6
    condFunction                   shift and go to state 7
    istrue                         shift and go to state 13

state 1

    (0) S' -> sentences .
    (1) sentences -> sentences . sentence
    (3) sentence -> . def
    (4) sentence -> . call
    (5) sentence -> . alter
    (6) sentence -> . not
    (7) sentence -> . condFunction
    (8) sentence -> . PRINT
    (19) def -> . DEF LP ID COMMA TYPE RP SEMICOLON
    (20) def -> . DEF LP ID COMMA TYPE COMMA value SEMICOLON
    (28) call -> . CALL LP ID RP SEMICOLON
    (21) alter -> . ALTER LP ID COMMA value RP SEMICOLON
    (22) not -> . NOT LP ID RP SEMICOLON
    (51) condFunction -> . istrue
    (23) istrue -> . ISTRUE LP ID RP SEMICOLON

    PRINT           shift and go to state 8
    DEF             shift and go to state 9
    CALL            shift and go to state 10
    ALTER           shift and go to state 11
    NOT             shift and go to state 12
    ISTRUE          shift and go to state 14

    sentence                       shift and go to state 15
    def                            shift and go to state 3
    call                           shift and go to state 4
    alter                          shift and go to state 5
    not                            shift and go to state 6
    condFunction                   shift and go to state 7
    istrue                         shift and go to state 13

state 2

    (2) sentences -> sentence .

    PRINT           reduce using rule 2 (sentences -> sentence .)
    DEF             reduce using rule 2 (sentences -> sentence .)
    CALL            reduce using rule 2 (sentences -> sentence .)
    ALTER           reduce using rule 2 (sentences -> sentence .)
    NOT             reduce using rule 2 (sentences -> sentence .)
    ISTRUE          reduce using rule 2 (sentences -> sentence .)
    $end            reduce using rule 2 (sentences -> sentence .)


state 3

    (3) sentence -> def .

    PRINT           reduce using rule 3 (sentence -> def .)
    DEF             reduce using rule 3 (sentence -> def .)
    CALL            reduce using rule 3 (sentence -> def .)
    ALTER           reduce using rule 3 (sentence -> def .)
    NOT             reduce using rule 3 (sentence -> def .)
    ISTRUE          reduce using rule 3 (sentence -> def .)
    $end            reduce using rule 3 (sentence -> def .)


state 4

    (4) sentence -> call .

    PRINT           reduce using rule 4 (sentence -> call .)
    DEF             reduce using rule 4 (sentence -> call .)
    CALL            reduce using rule 4 (sentence -> call .)
    ALTER           reduce using rule 4 (sentence -> call .)
    NOT             reduce using rule 4 (sentence -> call .)
    ISTRUE          reduce using rule 4 (sentence -> call .)
    $end            reduce using rule 4 (sentence -> call .)


state 5

    (5) sentence -> alter .

    PRINT           reduce using rule 5 (sentence -> alter .)
    DEF             reduce using rule 5 (sentence -> alter .)
    CALL            reduce using rule 5 (sentence -> alter .)
    ALTER           reduce using rule 5 (sentence -> alter .)
    NOT             reduce using rule 5 (sentence -> alter .)
    ISTRUE          reduce using rule 5 (sentence -> alter .)
    $end            reduce using rule 5 (sentence -> alter .)


state 6

    (6) sentence -> not .

    PRINT           reduce using rule 6 (sentence -> not .)
    DEF             reduce using rule 6 (sentence -> not .)
    CALL            reduce using rule 6 (sentence -> not .)
    ALTER           reduce using rule 6 (sentence -> not .)
    NOT             reduce using rule 6 (sentence -> not .)
    ISTRUE          reduce using rule 6 (sentence -> not .)
    $end            reduce using rule 6 (sentence -> not .)


state 7

    (7) sentence -> condFunction .

    PRINT           reduce using rule 7 (sentence -> condFunction .)
    DEF             reduce using rule 7 (sentence -> condFunction .)
    CALL            reduce using rule 7 (sentence -> condFunction .)
    ALTER           reduce using rule 7 (sentence -> condFunction .)
    NOT             reduce using rule 7 (sentence -> condFunction .)
    ISTRUE          reduce using rule 7 (sentence -> condFunction .)
    $end            reduce using rule 7 (sentence -> condFunction .)


state 8

    (8) sentence -> PRINT .

    PRINT           reduce using rule 8 (sentence -> PRINT .)
    DEF             reduce using rule 8 (sentence -> PRINT .)
    CALL            reduce using rule 8 (sentence -> PRINT .)
    ALTER           reduce using rule 8 (sentence -> PRINT .)
    NOT             reduce using rule 8 (sentence -> PRINT .)
    ISTRUE          reduce using rule 8 (sentence -> PRINT .)
    $end            reduce using rule 8 (sentence -> PRINT .)


state 9

    (19) def -> DEF . LP ID COMMA TYPE RP SEMICOLON
    (20) def -> DEF . LP ID COMMA TYPE COMMA value SEMICOLON

    LP              shift and go to state 16


state 10

    (28) call -> CALL . LP ID RP SEMICOLON

    LP              shift and go to state 17


state 11

    (21) alter -> ALTER . LP ID COMMA value RP SEMICOLON

    LP              shift and go to state 18


state 12

    (22) not -> NOT . LP ID RP SEMICOLON

    LP              shift and go to state 19


state 13

    (51) condFunction -> istrue .

    PRINT           reduce using rule 51 (condFunction -> istrue .)
    DEF             reduce using rule 51 (condFunction -> istrue .)
    CALL            reduce using rule 51 (condFunction -> istrue .)
    ALTER           reduce using rule 51 (condFunction -> istrue .)
    NOT             reduce using rule 51 (condFunction -> istrue .)
    ISTRUE          reduce using rule 51 (condFunction -> istrue .)
    $end            reduce using rule 51 (condFunction -> istrue .)


state 14

    (23) istrue -> ISTRUE . LP ID RP SEMICOLON

    LP              shift and go to state 20


state 15

    (1) sentences -> sentences sentence .

    PRINT           reduce using rule 1 (sentences -> sentences sentence .)
    DEF             reduce using rule 1 (sentences -> sentences sentence .)
    CALL            reduce using rule 1 (sentences -> sentences sentence .)
    ALTER           reduce using rule 1 (sentences -> sentences sentence .)
    NOT             reduce using rule 1 (sentences -> sentences sentence .)
    ISTRUE          reduce using rule 1 (sentences -> sentences sentence .)
    $end            reduce using rule 1 (sentences -> sentences sentence .)


state 16

    (19) def -> DEF LP . ID COMMA TYPE RP SEMICOLON
    (20) def -> DEF LP . ID COMMA TYPE COMMA value SEMICOLON

    ID              shift and go to state 21


state 17

    (28) call -> CALL LP . ID RP SEMICOLON

    ID              shift and go to state 22


state 18

    (21) alter -> ALTER LP . ID COMMA value RP SEMICOLON

    ID              shift and go to state 23


state 19

    (22) not -> NOT LP . ID RP SEMICOLON

    ID              shift and go to state 24


state 20

    (23) istrue -> ISTRUE LP . ID RP SEMICOLON

    ID              shift and go to state 25


state 21

    (19) def -> DEF LP ID . COMMA TYPE RP SEMICOLON
    (20) def -> DEF LP ID . COMMA TYPE COMMA value SEMICOLON

    COMMA           shift and go to state 26


state 22

    (28) call -> CALL LP ID . RP SEMICOLON

    RP              shift and go to state 27


state 23

    (21) alter -> ALTER LP ID . COMMA value RP SEMICOLON

    COMMA           shift and go to state 28


state 24

    (22) not -> NOT LP ID . RP SEMICOLON

    RP              shift and go to state 29


state 25

    (23) istrue -> ISTRUE LP ID . RP SEMICOLON

    RP              shift and go to state 30


state 26

    (19) def -> DEF LP ID COMMA . TYPE RP SEMICOLON
    (20) def -> DEF LP ID COMMA . TYPE COMMA value SEMICOLON

    TYPE            shift and go to state 31


state 27

    (28) call -> CALL LP ID RP . SEMICOLON

    SEMICOLON       shift and go to state 32


state 28

    (21) alter -> ALTER LP ID COMMA . value RP SEMICOLON
    (61) value -> . ID
    (62) value -> . INT
    (63) value -> . BOOL

    ID              shift and go to state 33
    INT             shift and go to state 35
    BOOL            shift and go to state 36

    value                          shift and go to state 34

state 29

    (22) not -> NOT LP ID RP . SEMICOLON

    SEMICOLON       shift and go to state 37


state 30

    (23) istrue -> ISTRUE LP ID RP . SEMICOLON

    SEMICOLON       shift and go to state 38


state 31

    (19) def -> DEF LP ID COMMA TYPE . RP SEMICOLON
    (20) def -> DEF LP ID COMMA TYPE . COMMA value SEMICOLON

    RP              shift and go to state 40
    COMMA           shift and go to state 39


state 32

    (28) call -> CALL LP ID RP SEMICOLON .

    PRINT           reduce using rule 28 (call -> CALL LP ID RP SEMICOLON .)
    DEF             reduce using rule 28 (call -> CALL LP ID RP SEMICOLON .)
    CALL            reduce using rule 28 (call -> CALL LP ID RP SEMICOLON .)
    ALTER           reduce using rule 28 (call -> CALL LP ID RP SEMICOLON .)
    NOT             reduce using rule 28 (call -> CALL LP ID RP SEMICOLON .)
    ISTRUE          reduce using rule 28 (call -> CALL LP ID RP SEMICOLON .)
    $end            reduce using rule 28 (call -> CALL LP ID RP SEMICOLON .)


state 33

    (61) value -> ID .

    RP              reduce using rule 61 (value -> ID .)
    SEMICOLON       reduce using rule 61 (value -> ID .)


state 34

    (21) alter -> ALTER LP ID COMMA value . RP SEMICOLON

    RP              shift and go to state 41


state 35

    (62) value -> INT .

    RP              reduce using rule 62 (value -> INT .)
    SEMICOLON       reduce using rule 62 (value -> INT .)


state 36

    (63) value -> BOOL .

    RP              reduce using rule 63 (value -> BOOL .)
    SEMICOLON       reduce using rule 63 (value -> BOOL .)


state 37

    (22) not -> NOT LP ID RP SEMICOLON .

    PRINT           reduce using rule 22 (not -> NOT LP ID RP SEMICOLON .)
    DEF             reduce using rule 22 (not -> NOT LP ID RP SEMICOLON .)
    CALL            reduce using rule 22 (not -> NOT LP ID RP SEMICOLON .)
    ALTER           reduce using rule 22 (not -> NOT LP ID RP SEMICOLON .)
    NOT             reduce using rule 22 (not -> NOT LP ID RP SEMICOLON .)
    ISTRUE          reduce using rule 22 (not -> NOT LP ID RP SEMICOLON .)
    $end            reduce using rule 22 (not -> NOT LP ID RP SEMICOLON .)


state 38

    (23) istrue -> ISTRUE LP ID RP SEMICOLON .

    PRINT           reduce using rule 23 (istrue -> ISTRUE LP ID RP SEMICOLON .)
    DEF             reduce using rule 23 (istrue -> ISTRUE LP ID RP SEMICOLON .)
    CALL            reduce using rule 23 (istrue -> ISTRUE LP ID RP SEMICOLON .)
    ALTER           reduce using rule 23 (istrue -> ISTRUE LP ID RP SEMICOLON .)
    NOT             reduce using rule 23 (istrue -> ISTRUE LP ID RP SEMICOLON .)
    ISTRUE          reduce using rule 23 (istrue -> ISTRUE LP ID RP SEMICOLON .)
    $end            reduce using rule 23 (istrue -> ISTRUE LP ID RP SEMICOLON .)


state 39

    (20) def -> DEF LP ID COMMA TYPE COMMA . value SEMICOLON
    (61) value -> . ID
    (62) value -> . INT
    (63) value -> . BOOL

    ID              shift and go to state 33
    INT             shift and go to state 35
    BOOL            shift and go to state 36

    value                          shift and go to state 42

state 40

    (19) def -> DEF LP ID COMMA TYPE RP . SEMICOLON

    SEMICOLON       shift and go to state 43


state 41

    (21) alter -> ALTER LP ID COMMA value RP . SEMICOLON

    SEMICOLON       shift and go to state 44


state 42

    (20) def -> DEF LP ID COMMA TYPE COMMA value . SEMICOLON

    SEMICOLON       shift and go to state 45


state 43

    (19) def -> DEF LP ID COMMA TYPE RP SEMICOLON .

    PRINT           reduce using rule 19 (def -> DEF LP ID COMMA TYPE RP SEMICOLON .)
    DEF             reduce using rule 19 (def -> DEF LP ID COMMA TYPE RP SEMICOLON .)
    CALL            reduce using rule 19 (def -> DEF LP ID COMMA TYPE RP SEMICOLON .)
    ALTER           reduce using rule 19 (def -> DEF LP ID COMMA TYPE RP SEMICOLON .)
    NOT             reduce using rule 19 (def -> DEF LP ID COMMA TYPE RP SEMICOLON .)
    ISTRUE          reduce using rule 19 (def -> DEF LP ID COMMA TYPE RP SEMICOLON .)
    $end            reduce using rule 19 (def -> DEF LP ID COMMA TYPE RP SEMICOLON .)


state 44

    (21) alter -> ALTER LP ID COMMA value RP SEMICOLON .

    PRINT           reduce using rule 21 (alter -> ALTER LP ID COMMA value RP SEMICOLON .)
    DEF             reduce using rule 21 (alter -> ALTER LP ID COMMA value RP SEMICOLON .)
    CALL            reduce using rule 21 (alter -> ALTER LP ID COMMA value RP SEMICOLON .)
    ALTER           reduce using rule 21 (alter -> ALTER LP ID COMMA value RP SEMICOLON .)
    NOT             reduce using rule 21 (alter -> ALTER LP ID COMMA value RP SEMICOLON .)
    ISTRUE          reduce using rule 21 (alter -> ALTER LP ID COMMA value RP SEMICOLON .)
    $end            reduce using rule 21 (alter -> ALTER LP ID COMMA value RP SEMICOLON .)


state 45

    (20) def -> DEF LP ID COMMA TYPE COMMA value SEMICOLON .

    PRINT           reduce using rule 20 (def -> DEF LP ID COMMA TYPE COMMA value SEMICOLON .)
    DEF             reduce using rule 20 (def -> DEF LP ID COMMA TYPE COMMA value SEMICOLON .)
    CALL            reduce using rule 20 (def -> DEF LP ID COMMA TYPE COMMA value SEMICOLON .)
    ALTER           reduce using rule 20 (def -> DEF LP ID COMMA TYPE COMMA value SEMICOLON .)
    NOT             reduce using rule 20 (def -> DEF LP ID COMMA TYPE COMMA value SEMICOLON .)
    ISTRUE          reduce using rule 20 (def -> DEF LP ID COMMA TYPE COMMA value SEMICOLON .)
    $end            reduce using rule 20 (def -> DEF LP ID COMMA TYPE COMMA value SEMICOLON .)

